/* dist/pretty-checkbox-react.es.js:1.1.0 */
import React__default,{forwardRef,createElement,cloneElement}from'react';function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}var classnames = createCommonjsModule(function (module) {
/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/

/* global define */
(function () {

  var hasOwn = {}.hasOwnProperty;

  function classNames() {
    var classes = [];

    for (var i = 0; i < arguments.length; i++) {
      var arg = arguments[i];
      if (!arg) continue;
      var argType = typeof arg;

      if (argType === 'string' || argType === 'number') {
        classes.push(arg);
      } else if (Array.isArray(arg) && arg.length) {
        var inner = classNames.apply(null, arg);

        if (inner) {
          classes.push(inner);
        }
      } else if (argType === 'object') {
        for (var key in arg) {
          if (hasOwn.call(arg, key) && arg[key]) {
            classes.push(key);
          }
        }
      }
    }

    return classes.join(' ');
  }

  if (module.exports) {
    classNames.default = classNames;
    module.exports = classNames;
  } else {
    window.classNames = classNames;
  }
})();
});/**
 * The base prefix for all pretty-checkbox class names.
 */

var PREFIX = 'p-';

/**
 * Automatically append the className for icon component. This will automatically add
 * `icon` to icon prop components, `svg` to prop svg components, and `image` to
 * image prop components.
 * @param {React.Element<*>} component The component to add the className to.
 * @param {string} className The className to fill on the element.
 */
var fillClassNameForIcons = function fillClassNameForIcons(component, className) {
  if (!component) {
    return null;
  }

  return cloneElement(component, _objectSpread({}, component.props, {
    className: classnames(className, component.props.className)
  }));
};
/**
 * Handles custom or default rendering of the pretty-checkbox `div.state` class.
 */


var PrettyInputState = function PrettyInputState(props) {
  var node = null;
  var children = props.children,
      render = props.render,
      id = props.id,
      color = props.color; // yuck, needed for type refinement :(

  if (props.svg) {
    node = {
      className: 'svg',
      node: props.svg
    };
  } else if (props.icon) {
    node = {
      className: 'icon',
      node: props.icon
    };
  } else if (props.image) {
    node = {
      className: 'image',
      node: props.image
    };
  }

  if (typeof children === 'function') {
    return children(node);
  }

  if (typeof render === 'function') {
    return render(node);
  }

  return createElement("div", {
    className: classnames('state', color ? PREFIX + color : null),
    "data-testid": "pcr-state"
  }, node ? fillClassNameForIcons(node.node, node.className) : null, createElement("label", {
    htmlFor: id
  }, children));
};

var Input = forwardRef(function (props, ref) {
  var className = props.className,
      value = props.value,
      onChange = props.onChange,
      id = props.id,
      type = props.type,
      inputProps = props.inputProps,
      animation = props.animation,
      checked = props.checked,
      disabled = props.disabled,
      locked = props.locked,
      bigger = props.bigger,
      shape = props.shape,
      style = props.style,
      plain = props.plain,
      _props$prettySelector = props.prettySelector,
      prettySelector = _props$prettySelector === void 0 ? 'pretty' : _props$prettySelector;

  if (props.icon && props.svg || props.icon && props.image || props.svg && props.image) {
    throw new Error('icon, svg, and image are mutually exclusive props; choose one');
  }

  return createElement("div", {
    "data-testid": "pcr-wrapper",
    className: classnames(prettySelector, animation ? PREFIX + animation : null, className, shape ? PREFIX + shape : null, style ? PREFIX + style : null, locked ? "".concat(PREFIX, "locked") : null, bigger ? "".concat(PREFIX, "bigger") : null, plain ? "".concat(PREFIX, "plain") : null)
  }, createElement("input", _extends({
    id: id || null,
    type: type,
    value: value,
    onChange: onChange,
    checked: checked,
    disabled: disabled,
    "data-testid": "pcr-input",
    ref: ref
  }, inputProps)), // $ExpectError
  createElement(PrettyInputState, props));
});
Input.displayName = 'Input';var getBaseClassName = function getBaseClassName(_ref, PREFIX) {
  var icon = _ref.icon,
      image = _ref.image,
      svg = _ref.svg;
  var base = "".concat(PREFIX, "default");

  if (icon) {
    base = "".concat(PREFIX, "icon");
  } else if (svg) {
    base = "".concat(PREFIX, "svg");
  } else if (image) {
    base = "".concat(PREFIX, "image");
  }

  return base;
};var Checkbox = React__default.forwardRef(function (props, ref) {
  var animation = props.animation,
      className = props.className,
      rest = _objectWithoutProperties(props, ["animation", "className"]);

  if (animation && animation !== 'smooth' && animation !== 'pulse' && !props.icon && !props.image && !props.svg) {
    throw new Error("animation '".concat(animation, "' is incompatible with default checkbox styles. You must specify an icon, image, or a svg."));
  }

  return React__default.createElement(Input, _extends({
    type: "checkbox",
    className: classnames( // $ExpectError
    getBaseClassName(props, PREFIX), props.indeterminate ? 'p-has-indeterminate' : null, className),
    animation: animation,
    ref: ref
  }, rest));
});
Checkbox.displayName = 'Checkbox';var Radio = React__default.forwardRef(function (props, ref) {
  var className = props.className,
      name = props.name,
      inputProps = props.inputProps,
      _props$shape = props.shape,
      shape = _props$shape === void 0 ? 'round' : _props$shape,
      rest = _objectWithoutProperties(props, ["className", "name", "inputProps", "shape"]);

  return React__default.createElement(Input, _extends({
    type: "radio",
    className: classnames( // $ExpectError
    getBaseClassName(props, PREFIX), className),
    inputProps: _objectSpread({}, inputProps, {
      name: name
    }),
    shape: shape,
    ref: ref
  }, rest));
});
Radio.displayName = 'Radio';var Switch = React__default.forwardRef(function (props, ref) {
  var _props$type = props.type,
      type = _props$type === void 0 ? 'checkbox' : _props$type,
      _props$shape = props.shape,
      shape = _props$shape === void 0 ? 'outline' : _props$shape,
      className = props.className,
      name = props.name,
      inputProps = props.inputProps,
      rest = _objectWithoutProperties(props, ["type", "shape", "className", "name", "inputProps"]);

  if (!shape || shape !== 'outline' && shape !== 'fill' && shape !== 'slim') {
    throw new Error('Shape can be one of the following: outline, fill, or slim');
  }

  if (!type) {
    throw new Error('type is required to be set');
  }

  if (rest.animation && rest.animation !== 'smooth' && rest.animation !== 'jelly' && rest.animation !== 'tada') {
    throw new Error('Switch animations can be one of the following: smooth, jelly, or tada');
  }

  return React__default.createElement(Input, _extends({
    className: classnames("".concat(PREFIX, "switch"), className),
    type: type,
    shape: shape,
    ref: ref,
    inputProps: _objectSpread({}, inputProps, {
      name: name
    })
  }, rest));
});
Switch.displayName = 'Switch';export{Checkbox,Input,Radio,Switch};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJldHR5LWNoZWNrYm94LXJlYWN0LmVzLmpzIiwic291cmNlcyI6WyIuLi9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9pbmRleC5qcyIsIi4uL3NyYy9jb21wb25lbnRzL0lucHV0LmpzIiwiLi4vc3JjL3V0aWxzL3V0aWxzLmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvQ2hlY2tib3guanMiLCIuLi9zcmMvY29tcG9uZW50cy9SYWRpby5qcyIsIi4uL3NyYy9jb21wb25lbnRzL1N3aXRjaC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAgQ29weXJpZ2h0IChjKSAyMDE3IEplZCBXYXRzb24uXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgc2VlXG4gIGh0dHA6Ly9qZWR3YXRzb24uZ2l0aHViLmlvL2NsYXNzbmFtZXNcbiovXG4vKiBnbG9iYWwgZGVmaW5lICovXG5cbihmdW5jdGlvbiAoKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG5cblx0ZnVuY3Rpb24gY2xhc3NOYW1lcyAoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpICYmIGFyZy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGlubmVyID0gY2xhc3NOYW1lcy5hcHBseShudWxsLCBhcmcpO1xuXHRcdFx0XHRpZiAoaW5uZXIpIHtcblx0XHRcdFx0XHRjbGFzc2VzLnB1c2goaW5uZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0XHRpZiAoaGFzT3duLmNhbGwoYXJnLCBrZXkpICYmIGFyZ1trZXldKSB7XG5cdFx0XHRcdFx0XHRjbGFzc2VzLnB1c2goa2V5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRjbGFzc05hbWVzLmRlZmF1bHQgPSBjbGFzc05hbWVzO1xuXHRcdG1vZHVsZS5leHBvcnRzID0gY2xhc3NOYW1lcztcblx0fSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gcmVnaXN0ZXIgYXMgJ2NsYXNzbmFtZXMnLCBjb25zaXN0ZW50IHdpdGggbnBtIHBhY2thZ2UgbmFtZVxuXHRcdGRlZmluZSgnY2xhc3NuYW1lcycsIFtdLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gY2xhc3NOYW1lcztcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XG5cdH1cbn0oKSk7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9wcm9wLXR5cGVzICovXG5cbi8vIEBmbG93XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIHByZWZpeCBmb3IgYWxsIHByZXR0eS1jaGVja2JveCBjbGFzcyBuYW1lcy5cbiAqL1xuZXhwb3J0IGNvbnN0IFBSRUZJWDogc3RyaW5nID0gJ3AtJztcblxudHlwZSBTVkcgPSB7fFxuICAgIC8qKlxuICAgICAqIFJlbmRlciBhIGN1c3RvbSBgLnN2Z2AgaW4gdGhlIGNoZWNrYm94IG9yIHJhZGlvLlxuICAgICAqL1xuICAgIHN2ZzogUmVhY3QuRWxlbWVudDwnc3ZnJz4sXG58fTtcblxudHlwZSBJbWFnZSA9IHt8XG4gICAgLyoqXG4gICAgICogUmVuZGVyIGEgY3VzdG9tIGBpbWdgIGluIHRoZSBjaGVja2JveCBvciByYWRpby5cbiAgICAgKi9cbiAgICBpbWFnZTogUmVhY3QuRWxlbWVudDwnaW1nJz4sXG58fTtcblxudHlwZSBJY29uID0ge3xcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYSBjdXN0b20gZm9udCBpY29uIGluIHRoZSBjaGVja2JveCBvciByYWRpby5cbiAgICAgKi9cbiAgICBpY29uOiBSZWFjdC5FbGVtZW50PGFueT4sXG58fTtcblxudHlwZSBOb2RlID0ge3xcbiAgICBjbGFzc05hbWU6IHN0cmluZyxcbiAgICBub2RlOiBhbnksXG58fSB8IG51bGw7XG5cbnR5cGUgQmFzZVByb3BzID0ge1xuICAgIC8qKlxuICAgICAqIFNlbGVjdCB0aGUgdHlwZSBpZiBjb21wb25lbnQ6IGNoZWNrYm94IG9yIHJhZGlvLlxuICAgICAqL1xuICAgIHR5cGU6ICdjaGVja2JveCcgfCAncmFkaW8nLFxuXG4gICAgLyoqXG4gICAgICogQ3VzdG9taXplIHRoZSByZW5kZXJpbmcgb2YgdGhlIGNoZWNrYm94LCByYWRpbyxcbiAgICAgKiBvciBzd2l0Y2guXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogWW91IGFyZSByZXNwb25zaWJsZSBmb3IgcHJvdmlkaW5nXG4gICAgICogdGhlIGRldGFpbHMgb2YgcHJldHR5LWNoZWNrYm94J3MgYGRpdi5zdGF0ZWAuXG4gICAgICovXG4gICAgY2hpbGRyZW4/OiBSZWFjdC5Ob2RlIHwgKE5vZGUgPT4gUmVhY3QuTm9kZSksXG5cbiAgICAvKipcbiAgICAgKiBDdXN0b21pemUgdGhlIHJlbmRlcmluZyBvZiB0aGUgY2hlY2tib3gsIHJhZGlvLFxuICAgICAqIG9yIHN3aXRjaC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBZb3UgYXJlIHJlc3BvbnNpYmxlIGZvciBwcm92aWRpbmdcbiAgICAgKiB0aGUgZGV0YWlscyBvZiBwcmV0dHktY2hlY2tib3gncyBgZGl2LnN0YXRlYC5cbiAgICAgKi9cbiAgICByZW5kZXI/OiBOb2RlID0+IFJlYWN0Lk5vZGUsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3R5bGUgb2YgdGhlIGNoZWNrYm94IG9yIHJhZGlvLlxuICAgICAqL1xuICAgIHN0eWxlPzogJ2ZpbGwnIHwgJ3RoaWNrJyxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaGFwZSBvZiB0aGUgY2hlY2tib3ggb3IgcmFkaW8gY29tcG9uZW50LlxuICAgICAqL1xuICAgIHNoYXBlPzogJ3JvdW5kJyB8ICdjdXJ2ZScgfCAnb3V0bGluZScgfCAnZmlsbCcgfCAnc2xpbScsXG5cbiAgICAvKipcbiAgICAgKiBBZGRpdGlvbmFsIGNsYXNzIHNlbGVjdG9ycyB0byBwYXNzIHRvIHRoZSBgcHJldHR5YCBlbGVtZW50LlxuICAgICAqL1xuICAgIGNsYXNzTmFtZT86IHN0cmluZyxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGlzIHRvIHlvdXIgY3VzdG9tIHZhbHVlIGZvciBgJHByZXR0eS0tY2xhc3MtbmFtZWAuIElmIHlvdSBoYXZlIG5vdCBjaGFuZ2VkXG4gICAgICogdGhpcyBpbiBgLnNjc3NgIHRoZW4gX2RvIG5vdCBtb2RpZnkgdGhpcyBwcm9wXy5cbiAgICAgKi9cbiAgICBwcmV0dHlTZWxlY3Rvcj86IHN0cmluZyxcblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgYSB2YWx1ZSBmb3IgdGhlIHVuZGVybHlpbmcgYGlucHV0YCBlbGVtZW50LlxuICAgICAqL1xuICAgIHZhbHVlPzogc3RyaW5nIHwgbnVtYmVyIHwgc3RyaW5nW10sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gZXZlbnQgaGFuZGxlciB3aGVuIHRoZSByYWRpby9jaGVja2JveC9zd2l0Y2ggY2hhbmdlcy5cbiAgICAgKi9cbiAgICBvbkNoYW5nZT86IChTeW50aGV0aWNNb3VzZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB2b2lkLFxuXG4gICAgLyoqXG4gICAgICogTmVlZCBhMTF5PyBBZGQgeW91ciBgaWRgIGhlcmUgYW5kIGl0J2xsIGF1dG9tYXRpY2FsbHkgYmUgYWRkZWQgdG8gdGhlIGBsYWJlbGBcbiAgICAgKiB3aGVuIHlvdSB1c2UgYGNoaWxkcmVuYCBhcyBhIHByb3AgYW5kIG5vdCBhIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGlkPzogc3RyaW5nLFxuXG4gICAgLyoqXG4gICAgICogQWRkaXRpb25hbCBpbnB1dCBwcm9wcyB0byBwYXNzIHRvIHRoZSBpbnB1dCBjb21wb25lbnQuXG4gICAgICovXG4gICAgaW5wdXRQcm9wcz86IHt9LFxuXG4gICAgLyoqXG4gICAgICogU3BlY2lmeSBjb2xvcnMgdG8gYWRkIHRvIHRoZSBjaGVja2JveCwgcmFkaW8sIG9yIHN3aXRjaC5cbiAgICAgKi9cbiAgICBjb2xvcj86IHN0cmluZyxcblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgYW5pbWF0aW9ucyB0byBhZGQgdG8gdGhlIGNoZWNrYm94LCByYWRpbywgb3Igc3dpdGNoLlxuICAgICAqL1xuICAgIGFuaW1hdGlvbj86ICdzbW9vdGgnIHwgJ2plbGx5JyB8ICd0YWRhJyB8ICdyb3RhdGUnIHwgJ3B1bHNlJyxcblxuICAgIC8qKlxuICAgICAqIENvbnRyb2wgdGhlIHN0YXRlIG9mIHlvdXIgY29tcG9uZW50IGJ5IGRlY2lkaW5nIHdoZW4gaXQgY2FuIGJlIGNoZWNrZWQvdW5jaGVja2VkLlxuICAgICAqL1xuICAgIGNoZWNrZWQ/OiBib29sZWFuLFxuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZSB0aGUgY2hlY2tib3gsIHJhZGlvLCBvciBzd2l0Y2guXG4gICAgICovXG4gICAgZGlzYWJsZWQ/OiBib29sZWFuLFxuXG4gICAgLyoqXG4gICAgICogTG9jayB0aGUgY2hlY2tib3gsIHJhZGlvLCBvciBzd2l0Y2guXG4gICAgICovXG4gICAgbG9ja2VkPzogYm9vbGVhbixcblxuICAgIC8qKlxuICAgICAqIE1ha2UgdGhlIGNoZWNrYm94LCByYWRpbywgb3Igc3dpdGNoIGJpZ2dlci5cbiAgICAgKi9cbiAgICBiaWdnZXI/OiBib29sZWFuLFxuXG4gICAgLyoqXG4gICAgICogU3R5bGUgdGhlIGNoZWNrYm94IG9yIHJhZGlvIGFzIHBsYWluLlxuICAgICAqL1xuICAgIHBsYWluPzogYm9vbGVhbixcbn07XG5cbmV4cG9ydCB0eXBlIElucHV0UHJvcHMgPVxuICAgIHwge1xuICAgICAgICAgIC4uLkJhc2VQcm9wcyxcbiAgICAgICAgICAuLi5TVkcsXG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgICAgLi4uQmFzZVByb3BzLFxuICAgICAgICAgIC4uLkltYWdlLFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICAgIC4uLkJhc2VQcm9wcyxcbiAgICAgICAgICAuLi5JY29uLFxuICAgICAgfTtcblxuLyoqXG4gKiBBdXRvbWF0aWNhbGx5IGFwcGVuZCB0aGUgY2xhc3NOYW1lIGZvciBpY29uIGNvbXBvbmVudC4gVGhpcyB3aWxsIGF1dG9tYXRpY2FsbHkgYWRkXG4gKiBgaWNvbmAgdG8gaWNvbiBwcm9wIGNvbXBvbmVudHMsIGBzdmdgIHRvIHByb3Agc3ZnIGNvbXBvbmVudHMsIGFuZCBgaW1hZ2VgIHRvXG4gKiBpbWFnZSBwcm9wIGNvbXBvbmVudHMuXG4gKiBAcGFyYW0ge1JlYWN0LkVsZW1lbnQ8Kj59IGNvbXBvbmVudCBUaGUgY29tcG9uZW50IHRvIGFkZCB0aGUgY2xhc3NOYW1lIHRvLlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSBUaGUgY2xhc3NOYW1lIHRvIGZpbGwgb24gdGhlIGVsZW1lbnQuXG4gKi9cbmNvbnN0IGZpbGxDbGFzc05hbWVGb3JJY29ucyA9IChcbiAgICBjb21wb25lbnQ6IFJlYWN0LkVsZW1lbnQ8YW55PiB8IHZvaWQsXG4gICAgY2xhc3NOYW1lOiBzdHJpbmdcbik6IFJlYWN0Lk5vZGUgPT4ge1xuICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY29tcG9uZW50LCB7XG4gICAgICAgIC4uLmNvbXBvbmVudC5wcm9wcyxcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzKGNsYXNzTmFtZSwgY29tcG9uZW50LnByb3BzLmNsYXNzTmFtZSksXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgY3VzdG9tIG9yIGRlZmF1bHQgcmVuZGVyaW5nIG9mIHRoZSBwcmV0dHktY2hlY2tib3ggYGRpdi5zdGF0ZWAgY2xhc3MuXG4gKi9cbmNvbnN0IFByZXR0eUlucHV0U3RhdGUgPSAocHJvcHM6IElucHV0UHJvcHMpOiBSZWFjdC5Ob2RlID0+IHtcbiAgICBsZXQgbm9kZTogTm9kZSA9IG51bGw7XG5cbiAgICBjb25zdCB7IGNoaWxkcmVuLCByZW5kZXIsIGlkLCBjb2xvciB9ID0gcHJvcHM7XG5cbiAgICAvLyB5dWNrLCBuZWVkZWQgZm9yIHR5cGUgcmVmaW5lbWVudCA6KFxuICAgIGlmIChwcm9wcy5zdmcpIHtcbiAgICAgICAgbm9kZSA9IHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3N2ZycsXG4gICAgICAgICAgICBub2RlOiBwcm9wcy5zdmcsXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChwcm9wcy5pY29uKSB7XG4gICAgICAgIG5vZGUgPSB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdpY29uJyxcbiAgICAgICAgICAgIG5vZGU6IHByb3BzLmljb24sXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChwcm9wcy5pbWFnZSkge1xuICAgICAgICBub2RlID0ge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnaW1hZ2UnLFxuICAgICAgICAgICAgbm9kZTogcHJvcHMuaW1hZ2UsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW4obm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiByZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlcihub2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoJ3N0YXRlJywgY29sb3IgPyBQUkVGSVggKyBjb2xvciA6IG51bGwpfVxuICAgICAgICAgICAgZGF0YS10ZXN0aWQ9XCJwY3Itc3RhdGVcIlxuICAgICAgICA+XG4gICAgICAgICAgICB7bm9kZSA/IGZpbGxDbGFzc05hbWVGb3JJY29ucyhub2RlLm5vZGUsIG5vZGUuY2xhc3NOYW1lKSA6IG51bGx9XG4gICAgICAgICAgICA8bGFiZWwgaHRtbEZvcj17aWR9PntjaGlsZHJlbn08L2xhYmVsPlxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufTtcblxuY29uc3QgSW5wdXQgPSBSZWFjdC5mb3J3YXJkUmVmPElucHV0UHJvcHMsIEhUTUxJbnB1dEVsZW1lbnQ+KChwcm9wcywgcmVmKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBvbkNoYW5nZSxcbiAgICAgICAgaWQsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGlucHV0UHJvcHMsXG4gICAgICAgIGFuaW1hdGlvbixcbiAgICAgICAgY2hlY2tlZCxcbiAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgIGxvY2tlZCxcbiAgICAgICAgYmlnZ2VyLFxuICAgICAgICBzaGFwZSxcbiAgICAgICAgc3R5bGUsXG4gICAgICAgIHBsYWluLFxuICAgICAgICBwcmV0dHlTZWxlY3RvciA9ICdwcmV0dHknLFxuICAgIH0gPSBwcm9wcztcblxuICAgIGlmIChcbiAgICAgICAgKHByb3BzLmljb24gJiYgcHJvcHMuc3ZnKSB8fFxuICAgICAgICAocHJvcHMuaWNvbiAmJiBwcm9wcy5pbWFnZSkgfHxcbiAgICAgICAgKHByb3BzLnN2ZyAmJiBwcm9wcy5pbWFnZSlcbiAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ2ljb24sIHN2ZywgYW5kIGltYWdlIGFyZSBtdXR1YWxseSBleGNsdXNpdmUgcHJvcHM7IGNob29zZSBvbmUnXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdlxuICAgICAgICAgICAgZGF0YS10ZXN0aWQ9XCJwY3Itd3JhcHBlclwiXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXG4gICAgICAgICAgICAgICAgcHJldHR5U2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uID8gUFJFRklYICsgYW5pbWF0aW9uIDogbnVsbCxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgc2hhcGUgPyBQUkVGSVggKyBzaGFwZSA6IG51bGwsXG4gICAgICAgICAgICAgICAgc3R5bGUgPyBQUkVGSVggKyBzdHlsZSA6IG51bGwsXG4gICAgICAgICAgICAgICAgbG9ja2VkID8gYCR7UFJFRklYfWxvY2tlZGAgOiBudWxsLFxuICAgICAgICAgICAgICAgIGJpZ2dlciA/IGAke1BSRUZJWH1iaWdnZXJgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBwbGFpbiA/IGAke1BSRUZJWH1wbGFpbmAgOiBudWxsXG4gICAgICAgICAgICApfVxuICAgICAgICA+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICBpZD17aWQgfHwgbnVsbH1cbiAgICAgICAgICAgICAgICB0eXBlPXt0eXBlfVxuICAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17b25DaGFuZ2V9XG4gICAgICAgICAgICAgICAgY2hlY2tlZD17Y2hlY2tlZH1cbiAgICAgICAgICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWR9XG4gICAgICAgICAgICAgICAgZGF0YS10ZXN0aWQ9XCJwY3ItaW5wdXRcIlxuICAgICAgICAgICAgICAgIHJlZj17cmVmfVxuICAgICAgICAgICAgICAgIHsuLi5pbnB1dFByb3BzfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyAkRXhwZWN0RXJyb3JcbiAgICAgICAgICAgICAgICA8UHJldHR5SW5wdXRTdGF0ZSB7Li4ucHJvcHN9IC8+XG4gICAgICAgICAgICB9XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59KTtcblxuSW5wdXQuZGlzcGxheU5hbWUgPSAnSW5wdXQnO1xuXG5leHBvcnQgZGVmYXVsdCBJbnB1dDtcbiIsIi8vIEBmbG93XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcblxudHlwZSBHZXRCYXNlQ2xhc3NOYW1lUHJvcHMgPSB7XG4gICAgaWNvbj86IFJlYWN0LkVsZW1lbnQ8YW55PixcbiAgICBzdmc/OiBSZWFjdC5FbGVtZW50PCdzdmcnPixcbiAgICBpbWFnZT86IFJlYWN0LkVsZW1lbnQ8J2ltZyc+XG59XG5cbmV4cG9ydCBjb25zdCBnZXRCYXNlQ2xhc3NOYW1lID0gKHsgaWNvbiwgaW1hZ2UsIHN2ZyB9OiBHZXRCYXNlQ2xhc3NOYW1lUHJvcHMsIFBSRUZJWDogc3RyaW5nKSA9PiB7XG4gICAgbGV0IGJhc2UgPSBgJHtQUkVGSVh9ZGVmYXVsdGA7XG5cbiAgICBpZiAoaWNvbikge1xuICAgICAgICBiYXNlID0gYCR7UFJFRklYfWljb25gO1xuICAgIH0gZWxzZSBpZiAoc3ZnKSB7XG4gICAgICAgIGJhc2UgPSBgJHtQUkVGSVh9c3ZnYDtcbiAgICB9IGVsc2UgaWYgKGltYWdlKSB7XG4gICAgICAgIGJhc2UgPSBgJHtQUkVGSVh9aW1hZ2VgO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlO1xufTtcbiIsIi8vIEBmbG93XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IGdldEJhc2VDbGFzc05hbWUgfSBmcm9tICcuLi91dGlscy91dGlscyc7XG5cbmltcG9ydCBJbnB1dCwgeyBQUkVGSVggfSBmcm9tICcuL0lucHV0JztcbmltcG9ydCB0eXBlIHsgSW5wdXRQcm9wcyB9IGZyb20gJy4vSW5wdXQnO1xuXG5leHBvcnQgdHlwZSBDaGVja2JveFByb3BzID0ge1xuICAgIC4uLklucHV0UHJvcHMsXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdHJ1ZSB3aGVuIHRoZSBjaGVja2JveCBpcyBpbiBhbiBpbmRldGVybWluYXRlIHN0YXRlLlxuICAgICAqL1xuICAgIGluZGV0ZXJtaW5hdGU/OiBib29sZWFuLFxufTtcblxuY29uc3QgQ2hlY2tib3ggPSBSZWFjdC5mb3J3YXJkUmVmPENoZWNrYm94UHJvcHMsIEhUTUxJbnB1dEVsZW1lbnQ+KFxuICAgIChwcm9wcywgcmVmKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgYW5pbWF0aW9uLCBjbGFzc05hbWUsIC4uLnJlc3QgfSA9IHByb3BzO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGFuaW1hdGlvbiAmJlxuICAgICAgICAgICAgYW5pbWF0aW9uICE9PSAnc21vb3RoJyAmJlxuICAgICAgICAgICAgYW5pbWF0aW9uICE9PSAncHVsc2UnICYmXG4gICAgICAgICAgICAhcHJvcHMuaWNvbiAmJlxuICAgICAgICAgICAgIXByb3BzLmltYWdlICYmXG4gICAgICAgICAgICAhcHJvcHMuc3ZnXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBhbmltYXRpb24gJyR7YW5pbWF0aW9ufScgaXMgaW5jb21wYXRpYmxlIHdpdGggZGVmYXVsdCBjaGVja2JveCBzdHlsZXMuIFlvdSBtdXN0IHNwZWNpZnkgYW4gaWNvbiwgaW1hZ2UsIG9yIGEgc3ZnLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPElucHV0XG4gICAgICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXG4gICAgICAgICAgICAgICAgICAgIC8vICRFeHBlY3RFcnJvclxuICAgICAgICAgICAgICAgICAgICBnZXRCYXNlQ2xhc3NOYW1lKHByb3BzLCBQUkVGSVgpLFxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5pbmRldGVybWluYXRlID8gJ3AtaGFzLWluZGV0ZXJtaW5hdGUnIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lXG4gICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICBhbmltYXRpb249e2FuaW1hdGlvbn1cbiAgICAgICAgICAgICAgICByZWY9e3JlZn1cbiAgICAgICAgICAgICAgICB7Li4ucmVzdH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICk7XG4gICAgfVxuKTtcblxuQ2hlY2tib3guZGlzcGxheU5hbWUgPSAnQ2hlY2tib3gnO1xuXG5leHBvcnQgZGVmYXVsdCBDaGVja2JveDtcbiIsIi8vIEBmbG93XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IGdldEJhc2VDbGFzc05hbWUgfSBmcm9tICcuLi91dGlscy91dGlscyc7XG5cbmltcG9ydCBJbnB1dCwgeyBQUkVGSVggfSBmcm9tICcuL0lucHV0JztcbmltcG9ydCB0eXBlIHsgSW5wdXRQcm9wcyB9IGZyb20gJy4vSW5wdXQnO1xuXG5leHBvcnQgdHlwZSBSYWRpb1Byb3BzID0ge1xuICAgIC4uLklucHV0UHJvcHMsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgcmFkaW8gZ3JvdXAuXG4gICAgICovXG4gICAgbmFtZTogc3RyaW5nLFxufTtcblxuY29uc3QgUmFkaW8gPSBSZWFjdC5mb3J3YXJkUmVmPFJhZGlvUHJvcHMsIEhUTUxJbnB1dEVsZW1lbnQ+KChwcm9wcywgcmVmKSA9PiB7XG4gICAgY29uc3QgeyBjbGFzc05hbWUsIG5hbWUsIGlucHV0UHJvcHMsIHNoYXBlID0gJ3JvdW5kJywgLi4ucmVzdCB9ID0gcHJvcHM7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgIHR5cGU9XCJyYWRpb1wiXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXG4gICAgICAgICAgICAgICAgLy8gJEV4cGVjdEVycm9yXG4gICAgICAgICAgICAgICAgZ2V0QmFzZUNsYXNzTmFtZShwcm9wcywgUFJFRklYKSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWVcbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICBpbnB1dFByb3BzPXt7IC4uLmlucHV0UHJvcHMsIG5hbWU6IG5hbWUgfX1cbiAgICAgICAgICAgIHNoYXBlPXtzaGFwZX1cbiAgICAgICAgICAgIHJlZj17cmVmfVxuICAgICAgICAgICAgey4uLnJlc3R9XG4gICAgICAgIC8+XG4gICAgKTtcbn0pO1xuXG5SYWRpby5kaXNwbGF5TmFtZSA9ICdSYWRpbyc7XG5cbmV4cG9ydCBkZWZhdWx0IFJhZGlvO1xuIiwiLy8gQGZsb3dcblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuXG5pbXBvcnQgSW5wdXQsIHsgUFJFRklYIH0gZnJvbSAnLi9JbnB1dCc7XG5pbXBvcnQgdHlwZSB7IElucHV0UHJvcHMgfSBmcm9tICcuL0lucHV0JztcblxuZXhwb3J0IHR5cGUgU3dpdGNoUHJvcHMgPSB7XG4gICAgLi4uSW5wdXRQcm9wcyxcblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgYW5pbWF0aW9uIGZvciB0aGUgYFN3aXRjaGAgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGFuaW1hdGlvbj86ICdzbW9vdGgnIHwgJ2plbGx5JyB8ICd0YWRhJyxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaGFwZSBvZiB0aGUgYFN3aXRjaGAgY29tcG9uZW50LlxuICAgICAqL1xuICAgIHNoYXBlPzogJ291dGxpbmUnIHwgJ2ZpbGwnIHwgJ3NsaW0nLFxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZSBhIG5hbWUgd2hlbiBgdHlwZWAgaXMgYHJhZGlvYC5cbiAgICAgKi9cbiAgICBuYW1lPzogc3RyaW5nLFxufTtcblxuY29uc3QgU3dpdGNoID0gUmVhY3QuZm9yd2FyZFJlZjxTd2l0Y2hQcm9wcywgSFRNTElucHV0RWxlbWVudD4oKHByb3BzLCByZWYpID0+IHtcbiAgICBjb25zdCB7IHR5cGUgPSAnY2hlY2tib3gnLCBzaGFwZSA9ICdvdXRsaW5lJywgY2xhc3NOYW1lLCBuYW1lLCBpbnB1dFByb3BzLCAuLi5yZXN0IH0gPSBwcm9wcztcblxuICAgIGlmIChcbiAgICAgICAgIXNoYXBlIHx8XG4gICAgICAgIChzaGFwZSAhPT0gJ291dGxpbmUnICYmIHNoYXBlICE9PSAnZmlsbCcgJiYgc2hhcGUgIT09ICdzbGltJylcbiAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1NoYXBlIGNhbiBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZzogb3V0bGluZSwgZmlsbCwgb3Igc2xpbSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eXBlIGlzIHJlcXVpcmVkIHRvIGJlIHNldCcpO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICAgcmVzdC5hbmltYXRpb24gJiZcbiAgICAgICAgcmVzdC5hbmltYXRpb24gIT09ICdzbW9vdGgnICYmXG4gICAgICAgIHJlc3QuYW5pbWF0aW9uICE9PSAnamVsbHknICYmXG4gICAgICAgIHJlc3QuYW5pbWF0aW9uICE9PSAndGFkYSdcbiAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1N3aXRjaCBhbmltYXRpb25zIGNhbiBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZzogc21vb3RoLCBqZWxseSwgb3IgdGFkYSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhgJHtQUkVGSVh9c3dpdGNoYCwgY2xhc3NOYW1lKX1cbiAgICAgICAgICAgIHR5cGU9e3R5cGV9XG4gICAgICAgICAgICBzaGFwZT17c2hhcGV9XG4gICAgICAgICAgICByZWY9e3JlZn1cbiAgICAgICAgICAgIGlucHV0UHJvcHM9e3sgLi4uaW5wdXRQcm9wcywgbmFtZTogbmFtZSB9fVxuICAgICAgICAgICAgey4uLnJlc3R9XG4gICAgICAgIC8+XG4gICAgKTtcbn0pO1xuXG5Td2l0Y2guZGlzcGxheU5hbWUgPSAnU3dpdGNoJztcblxuZXhwb3J0IGRlZmF1bHQgU3dpdGNoO1xuIl0sIm5hbWVzIjpbImhhc093biIsImhhc093blByb3BlcnR5IiwiY2xhc3NOYW1lcyIsImNsYXNzZXMiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXJnIiwiYXJnVHlwZSIsInB1c2giLCJBcnJheSIsImlzQXJyYXkiLCJpbm5lciIsImFwcGx5Iiwia2V5IiwiY2FsbCIsImpvaW4iLCJtb2R1bGUiLCJleHBvcnRzIiwiZGVmYXVsdCIsIndpbmRvdyIsIlBSRUZJWCIsImZpbGxDbGFzc05hbWVGb3JJY29ucyIsImNvbXBvbmVudCIsImNsYXNzTmFtZSIsIlJlYWN0IiwicHJvcHMiLCJQcmV0dHlJbnB1dFN0YXRlIiwibm9kZSIsImNoaWxkcmVuIiwicmVuZGVyIiwiaWQiLCJjb2xvciIsInN2ZyIsImljb24iLCJpbWFnZSIsIlJlYWN0LmNyZWF0ZUVsZW1lbnQiLCJJbnB1dCIsInJlZiIsInZhbHVlIiwib25DaGFuZ2UiLCJ0eXBlIiwiaW5wdXRQcm9wcyIsImFuaW1hdGlvbiIsImNoZWNrZWQiLCJkaXNhYmxlZCIsImxvY2tlZCIsImJpZ2dlciIsInNoYXBlIiwic3R5bGUiLCJwbGFpbiIsInByZXR0eVNlbGVjdG9yIiwiRXJyb3IiLCJkaXNwbGF5TmFtZSIsImdldEJhc2VDbGFzc05hbWUiLCJiYXNlIiwiQ2hlY2tib3giLCJmb3J3YXJkUmVmIiwicmVzdCIsImluZGV0ZXJtaW5hdGUiLCJSYWRpbyIsIm5hbWUiLCJTd2l0Y2giXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFPQyxhQUFZOztNQUdSQSxNQUFNLEdBQUcsR0FBR0MsY0FBaEI7O1dBRVNDLFVBQVQsR0FBdUI7UUFDbEJDLE9BQU8sR0FBRyxFQUFkOztTQUVLLElBQUlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdDLFNBQVMsQ0FBQ0MsTUFBOUIsRUFBc0NGLENBQUMsRUFBdkMsRUFBMkM7VUFDdENHLEdBQUcsR0FBR0YsU0FBUyxDQUFDRCxDQUFELENBQW5CO1VBQ0ksQ0FBQ0csR0FBTCxFQUFVO1VBRU5DLE9BQU8sR0FBRyxPQUFPRCxHQUFyQjs7VUFFSUMsT0FBTyxLQUFLLFFBQVosSUFBd0JBLE9BQU8sS0FBSyxRQUF4QyxFQUFrRDtRQUNqREwsT0FBTyxDQUFDTSxJQUFSLENBQWFGLEdBQWI7T0FERCxNQUVPLElBQUlHLEtBQUssQ0FBQ0MsT0FBTixDQUFjSixHQUFkLEtBQXNCQSxHQUFHLENBQUNELE1BQTlCLEVBQXNDO1lBQ3hDTSxLQUFLLEdBQUdWLFVBQVUsQ0FBQ1csS0FBWCxDQUFpQixJQUFqQixFQUF1Qk4sR0FBdkIsQ0FBWjs7WUFDSUssS0FBSixFQUFXO1VBQ1ZULE9BQU8sQ0FBQ00sSUFBUixDQUFhRyxL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
