/* dist/pretty-checkbox-react.cjs.js:1.1.0 */
'use strict';Object.defineProperty(exports,'__esModule',{value:true});function _interopDefault(e){return(e&&(typeof e==='object')&&'default'in e)?e['default']:e}var React=require('react'),React__default=_interopDefault(React);function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}var classnames = createCommonjsModule(function (module) {
/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/

/* global define */
(function () {

  var hasOwn = {}.hasOwnProperty;

  function classNames() {
    var classes = [];

    for (var i = 0; i < arguments.length; i++) {
      var arg = arguments[i];
      if (!arg) continue;
      var argType = typeof arg;

      if (argType === 'string' || argType === 'number') {
        classes.push(arg);
      } else if (Array.isArray(arg) && arg.length) {
        var inner = classNames.apply(null, arg);

        if (inner) {
          classes.push(inner);
        }
      } else if (argType === 'object') {
        for (var key in arg) {
          if (hasOwn.call(arg, key) && arg[key]) {
            classes.push(key);
          }
        }
      }
    }

    return classes.join(' ');
  }

  if (module.exports) {
    classNames.default = classNames;
    module.exports = classNames;
  } else {
    window.classNames = classNames;
  }
})();
});/**
 * The base prefix for all pretty-checkbox class names.
 */

var PREFIX = 'p-';

/**
 * Automatically append the className for icon component. This will automatically add
 * `icon` to icon prop components, `svg` to prop svg components, and `image` to
 * image prop components.
 * @param {React.Element<*>} component The component to add the className to.
 * @param {string} className The className to fill on the element.
 */
var fillClassNameForIcons = function fillClassNameForIcons(component, className) {
  if (!component) {
    return null;
  }

  return React.cloneElement(component, _objectSpread({}, component.props, {
    className: classnames(className, component.props.className)
  }));
};
/**
 * Handles custom or default rendering of the pretty-checkbox `div.state` class.
 */


var PrettyInputState = function PrettyInputState(props) {
  var node = null;
  var children = props.children,
      render = props.render,
      id = props.id,
      color = props.color; // yuck, needed for type refinement :(

  if (props.svg) {
    node = {
      className: 'svg',
      node: props.svg
    };
  } else if (props.icon) {
    node = {
      className: 'icon',
      node: props.icon
    };
  } else if (props.image) {
    node = {
      className: 'image',
      node: props.image
    };
  }

  if (typeof children === 'function') {
    return children(node);
  }

  if (typeof render === 'function') {
    return render(node);
  }

  return React.createElement("div", {
    className: classnames('state', color ? PREFIX + color : null),
    "data-testid": "pcr-state"
  }, node ? fillClassNameForIcons(node.node, node.className) : null, React.createElement("label", {
    htmlFor: id
  }, children));
};

var Input = React.forwardRef(function (props, ref) {
  var className = props.className,
      value = props.value,
      onChange = props.onChange,
      id = props.id,
      type = props.type,
      inputProps = props.inputProps,
      animation = props.animation,
      checked = props.checked,
      disabled = props.disabled,
      locked = props.locked,
      bigger = props.bigger,
      shape = props.shape,
      style = props.style,
      plain = props.plain,
      _props$prettySelector = props.prettySelector,
      prettySelector = _props$prettySelector === void 0 ? 'pretty' : _props$prettySelector;

  if (props.icon && props.svg || props.icon && props.image || props.svg && props.image) {
    throw new Error('icon, svg, and image are mutually exclusive props; choose one');
  }

  return React.createElement("div", {
    "data-testid": "pcr-wrapper",
    className: classnames(prettySelector, animation ? PREFIX + animation : null, className, shape ? PREFIX + shape : null, style ? PREFIX + style : null, locked ? "".concat(PREFIX, "locked") : null, bigger ? "".concat(PREFIX, "bigger") : null, plain ? "".concat(PREFIX, "plain") : null)
  }, React.createElement("input", _extends({
    id: id || null,
    type: type,
    value: value,
    onChange: onChange,
    checked: checked,
    disabled: disabled,
    "data-testid": "pcr-input",
    ref: ref
  }, inputProps)), // $ExpectError
  React.createElement(PrettyInputState, props));
});
Input.displayName = 'Input';var getBaseClassName = function getBaseClassName(_ref, PREFIX) {
  var icon = _ref.icon,
      image = _ref.image,
      svg = _ref.svg;
  var base = "".concat(PREFIX, "default");

  if (icon) {
    base = "".concat(PREFIX, "icon");
  } else if (svg) {
    base = "".concat(PREFIX, "svg");
  } else if (image) {
    base = "".concat(PREFIX, "image");
  }

  return base;
};var Checkbox = React__default.forwardRef(function (props, ref) {
  var animation = props.animation,
      className = props.className,
      rest = _objectWithoutProperties(props, ["animation", "className"]);

  if (animation && animation !== 'smooth' && animation !== 'pulse' && !props.icon && !props.image && !props.svg) {
    throw new Error("animation '".concat(animation, "' is incompatible with default checkbox styles. You must specify an icon, image, or a svg."));
  }

  return React__default.createElement(Input, _extends({
    type: "checkbox",
    className: classnames( // $ExpectError
    getBaseClassName(props, PREFIX), props.indeterminate ? 'p-has-indeterminate' : null, className),
    animation: animation,
    ref: ref
  }, rest));
});
Checkbox.displayName = 'Checkbox';var Radio = React__default.forwardRef(function (props, ref) {
  var className = props.className,
      name = props.name,
      inputProps = props.inputProps,
      _props$shape = props.shape,
      shape = _props$shape === void 0 ? 'round' : _props$shape,
      rest = _objectWithoutProperties(props, ["className", "name", "inputProps", "shape"]);

  return React__default.createElement(Input, _extends({
    type: "radio",
    className: classnames( // $ExpectError
    getBaseClassName(props, PREFIX), className),
    inputProps: _objectSpread({}, inputProps, {
      name: name
    }),
    shape: shape,
    ref: ref
  }, rest));
});
Radio.displayName = 'Radio';var Switch = React__default.forwardRef(function (props, ref) {
  var _props$type = props.type,
      type = _props$type === void 0 ? 'checkbox' : _props$type,
      _props$shape = props.shape,
      shape = _props$shape === void 0 ? 'outline' : _props$shape,
      className = props.className,
      name = props.name,
      inputProps = props.inputProps,
      rest = _objectWithoutProperties(props, ["type", "shape", "className", "name", "inputProps"]);

  if (!shape || shape !== 'outline' && shape !== 'fill' && shape !== 'slim') {
    throw new Error('Shape can be one of the following: outline, fill, or slim');
  }

  if (!type) {
    throw new Error('type is required to be set');
  }

  if (rest.animation && rest.animation !== 'smooth' && rest.animation !== 'jelly' && rest.animation !== 'tada') {
    throw new Error('Switch animations can be one of the following: smooth, jelly, or tada');
  }

  return React__default.createElement(Input, _extends({
    className: classnames("".concat(PREFIX, "switch"), className),
    type: type,
    shape: shape,
    ref: ref,
    inputProps: _objectSpread({}, inputProps, {
      name: name
    })
  }, rest));
});
Switch.displayName = 'Switch';exports.Checkbox=Checkbox;exports.Input=Input;exports.Radio=Radio;exports.Switch=Switch;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJldHR5LWNoZWNrYm94LXJlYWN0LmNqcy5qcyIsInNvdXJjZXMiOlsiLi4vbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanMiLCIuLi9zcmMvY29tcG9uZW50cy9JbnB1dC5qcyIsIi4uL3NyYy91dGlscy91dGlscy5qcyIsIi4uL3NyYy9jb21wb25lbnRzL0NoZWNrYm94LmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvUmFkaW8uanMiLCIuLi9zcmMvY29tcG9uZW50cy9Td2l0Y2guanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gIENvcHlyaWdodCAoYykgMjAxNyBKZWQgV2F0c29uLlxuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHNlZVxuICBodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG4qL1xuLyogZ2xvYmFsIGRlZmluZSAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdGZ1bmN0aW9uIGNsYXNzTmFtZXMgKCkge1xuXHRcdHZhciBjbGFzc2VzID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdGlmICghYXJnKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xuXG5cdFx0XHRpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycgfHwgYXJnVHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGFyZyk7XG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSAmJiBhcmcubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBpbm5lciA9IGNsYXNzTmFtZXMuYXBwbHkobnVsbCwgYXJnKTtcblx0XHRcdFx0aWYgKGlubmVyKSB7XG5cdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGlubmVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG5cdFx0XHRcdFx0aWYgKGhhc093bi5jYWxsKGFyZywga2V5KSAmJiBhcmdba2V5XSkge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0Y2xhc3NOYW1lcy5kZWZhdWx0ID0gY2xhc3NOYW1lcztcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcblx0XHRkZWZpbmUoJ2NsYXNzbmFtZXMnLCBbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGNsYXNzTmFtZXM7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuXHR9XG59KCkpO1xuIiwiLyogZXNsaW50LWRpc2FibGUgcmVhY3QvcHJvcC10eXBlcyAqL1xuXG4vLyBAZmxvd1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBwcmVmaXggZm9yIGFsbCBwcmV0dHktY2hlY2tib3ggY2xhc3MgbmFtZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBQUkVGSVg6IHN0cmluZyA9ICdwLSc7XG5cbnR5cGUgU1ZHID0ge3xcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYSBjdXN0b20gYC5zdmdgIGluIHRoZSBjaGVja2JveCBvciByYWRpby5cbiAgICAgKi9cbiAgICBzdmc6IFJlYWN0LkVsZW1lbnQ8J3N2Zyc+LFxufH07XG5cbnR5cGUgSW1hZ2UgPSB7fFxuICAgIC8qKlxuICAgICAqIFJlbmRlciBhIGN1c3RvbSBgaW1nYCBpbiB0aGUgY2hlY2tib3ggb3IgcmFkaW8uXG4gICAgICovXG4gICAgaW1hZ2U6IFJlYWN0LkVsZW1lbnQ8J2ltZyc+LFxufH07XG5cbnR5cGUgSWNvbiA9IHt8XG4gICAgLyoqXG4gICAgICogUmVuZGVyIGEgY3VzdG9tIGZvbnQgaWNvbiBpbiB0aGUgY2hlY2tib3ggb3IgcmFkaW8uXG4gICAgICovXG4gICAgaWNvbjogUmVhY3QuRWxlbWVudDxhbnk+LFxufH07XG5cbnR5cGUgTm9kZSA9IHt8XG4gICAgY2xhc3NOYW1lOiBzdHJpbmcsXG4gICAgbm9kZTogYW55LFxufH0gfCBudWxsO1xuXG50eXBlIEJhc2VQcm9wcyA9IHtcbiAgICAvKipcbiAgICAgKiBTZWxlY3QgdGhlIHR5cGUgaWYgY29tcG9uZW50OiBjaGVja2JveCBvciByYWRpby5cbiAgICAgKi9cbiAgICB0eXBlOiAnY2hlY2tib3gnIHwgJ3JhZGlvJyxcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbWl6ZSB0aGUgcmVuZGVyaW5nIG9mIHRoZSBjaGVja2JveCwgcmFkaW8sXG4gICAgICogb3Igc3dpdGNoLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFlvdSBhcmUgcmVzcG9uc2libGUgZm9yIHByb3ZpZGluZ1xuICAgICAqIHRoZSBkZXRhaWxzIG9mIHByZXR0eS1jaGVja2JveCdzIGBkaXYuc3RhdGVgLlxuICAgICAqL1xuICAgIGNoaWxkcmVuPzogUmVhY3QuTm9kZSB8IChOb2RlID0+IFJlYWN0Lk5vZGUpLFxuXG4gICAgLyoqXG4gICAgICogQ3VzdG9taXplIHRoZSByZW5kZXJpbmcgb2YgdGhlIGNoZWNrYm94LCByYWRpbyxcbiAgICAgKiBvciBzd2l0Y2guXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogWW91IGFyZSByZXNwb25zaWJsZSBmb3IgcHJvdmlkaW5nXG4gICAgICogdGhlIGRldGFpbHMgb2YgcHJldHR5LWNoZWNrYm94J3MgYGRpdi5zdGF0ZWAuXG4gICAgICovXG4gICAgcmVuZGVyPzogTm9kZSA9PiBSZWFjdC5Ob2RlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHN0eWxlIG9mIHRoZSBjaGVja2JveCBvciByYWRpby5cbiAgICAgKi9cbiAgICBzdHlsZT86ICdmaWxsJyB8ICd0aGljaycsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2hhcGUgb2YgdGhlIGNoZWNrYm94IG9yIHJhZGlvIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBzaGFwZT86ICdyb3VuZCcgfCAnY3VydmUnIHwgJ291dGxpbmUnIHwgJ2ZpbGwnIHwgJ3NsaW0nLFxuXG4gICAgLyoqXG4gICAgICogQWRkaXRpb25hbCBjbGFzcyBzZWxlY3RvcnMgdG8gcGFzcyB0byB0aGUgYHByZXR0eWAgZWxlbWVudC5cbiAgICAgKi9cbiAgICBjbGFzc05hbWU/OiBzdHJpbmcsXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhpcyB0byB5b3VyIGN1c3RvbSB2YWx1ZSBmb3IgYCRwcmV0dHktLWNsYXNzLW5hbWVgLiBJZiB5b3UgaGF2ZSBub3QgY2hhbmdlZFxuICAgICAqIHRoaXMgaW4gYC5zY3NzYCB0aGVuIF9kbyBub3QgbW9kaWZ5IHRoaXMgcHJvcF8uXG4gICAgICovXG4gICAgcHJldHR5U2VsZWN0b3I/OiBzdHJpbmcsXG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IGEgdmFsdWUgZm9yIHRoZSB1bmRlcmx5aW5nIGBpbnB1dGAgZWxlbWVudC5cbiAgICAgKi9cbiAgICB2YWx1ZT86IHN0cmluZyB8IG51bWJlciB8IHN0cmluZ1tdLFxuXG4gICAgLyoqXG4gICAgICogQWRkIGFuIGV2ZW50IGhhbmRsZXIgd2hlbiB0aGUgcmFkaW8vY2hlY2tib3gvc3dpdGNoIGNoYW5nZXMuXG4gICAgICovXG4gICAgb25DaGFuZ2U/OiAoU3ludGhldGljTW91c2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4gdm9pZCxcblxuICAgIC8qKlxuICAgICAqIE5lZWQgYTExeT8gQWRkIHlvdXIgYGlkYCBoZXJlIGFuZCBpdCdsbCBhdXRvbWF0aWNhbGx5IGJlIGFkZGVkIHRvIHRoZSBgbGFiZWxgXG4gICAgICogd2hlbiB5b3UgdXNlIGBjaGlsZHJlbmAgYXMgYSBwcm9wIGFuZCBub3QgYSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBpZD86IHN0cmluZyxcblxuICAgIC8qKlxuICAgICAqIEFkZGl0aW9uYWwgaW5wdXQgcHJvcHMgdG8gcGFzcyB0byB0aGUgaW5wdXQgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGlucHV0UHJvcHM/OiB7fSxcblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgY29sb3JzIHRvIGFkZCB0byB0aGUgY2hlY2tib3gsIHJhZGlvLCBvciBzd2l0Y2guXG4gICAgICovXG4gICAgY29sb3I/OiBzdHJpbmcsXG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IGFuaW1hdGlvbnMgdG8gYWRkIHRvIHRoZSBjaGVja2JveCwgcmFkaW8sIG9yIHN3aXRjaC5cbiAgICAgKi9cbiAgICBhbmltYXRpb24/OiAnc21vb3RoJyB8ICdqZWxseScgfCAndGFkYScgfCAncm90YXRlJyB8ICdwdWxzZScsXG5cbiAgICAvKipcbiAgICAgKiBDb250cm9sIHRoZSBzdGF0ZSBvZiB5b3VyIGNvbXBvbmVudCBieSBkZWNpZGluZyB3aGVuIGl0IGNhbiBiZSBjaGVja2VkL3VuY2hlY2tlZC5cbiAgICAgKi9cbiAgICBjaGVja2VkPzogYm9vbGVhbixcblxuICAgIC8qKlxuICAgICAqIERpc2FibGUgdGhlIGNoZWNrYm94LCByYWRpbywgb3Igc3dpdGNoLlxuICAgICAqL1xuICAgIGRpc2FibGVkPzogYm9vbGVhbixcblxuICAgIC8qKlxuICAgICAqIExvY2sgdGhlIGNoZWNrYm94LCByYWRpbywgb3Igc3dpdGNoLlxuICAgICAqL1xuICAgIGxvY2tlZD86IGJvb2xlYW4sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHRoZSBjaGVja2JveCwgcmFkaW8sIG9yIHN3aXRjaCBiaWdnZXIuXG4gICAgICovXG4gICAgYmlnZ2VyPzogYm9vbGVhbixcblxuICAgIC8qKlxuICAgICAqIFN0eWxlIHRoZSBjaGVja2JveCBvciByYWRpbyBhcyBwbGFpbi5cbiAgICAgKi9cbiAgICBwbGFpbj86IGJvb2xlYW4sXG59O1xuXG5leHBvcnQgdHlwZSBJbnB1dFByb3BzID1cbiAgICB8IHtcbiAgICAgICAgICAuLi5CYXNlUHJvcHMsXG4gICAgICAgICAgLi4uU1ZHLFxuICAgICAgfVxuICAgIHwge1xuICAgICAgICAgIC4uLkJhc2VQcm9wcyxcbiAgICAgICAgICAuLi5JbWFnZSxcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgICAuLi5CYXNlUHJvcHMsXG4gICAgICAgICAgLi4uSWNvbixcbiAgICAgIH07XG5cbi8qKlxuICogQXV0b21hdGljYWxseSBhcHBlbmQgdGhlIGNsYXNzTmFtZSBmb3IgaWNvbiBjb21wb25lbnQuIFRoaXMgd2lsbCBhdXRvbWF0aWNhbGx5IGFkZFxuICogYGljb25gIHRvIGljb24gcHJvcCBjb21wb25lbnRzLCBgc3ZnYCB0byBwcm9wIHN2ZyBjb21wb25lbnRzLCBhbmQgYGltYWdlYCB0b1xuICogaW1hZ2UgcHJvcCBjb21wb25lbnRzLlxuICogQHBhcmFtIHtSZWFjdC5FbGVtZW50PCo+fSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byBhZGQgdGhlIGNsYXNzTmFtZSB0by5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgVGhlIGNsYXNzTmFtZSB0byBmaWxsIG9uIHRoZSBlbGVtZW50LlxuICovXG5jb25zdCBmaWxsQ2xhc3NOYW1lRm9ySWNvbnMgPSAoXG4gICAgY29tcG9uZW50OiBSZWFjdC5FbGVtZW50PGFueT4gfCB2b2lkLFxuICAgIGNsYXNzTmFtZTogc3RyaW5nXG4pOiBSZWFjdC5Ob2RlID0+IHtcbiAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGNvbXBvbmVudCwge1xuICAgICAgICAuLi5jb21wb25lbnQucHJvcHMsXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcyhjbGFzc05hbWUsIGNvbXBvbmVudC5wcm9wcy5jbGFzc05hbWUpLFxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBIYW5kbGVzIGN1c3RvbSBvciBkZWZhdWx0IHJlbmRlcmluZyBvZiB0aGUgcHJldHR5LWNoZWNrYm94IGBkaXYuc3RhdGVgIGNsYXNzLlxuICovXG5jb25zdCBQcmV0dHlJbnB1dFN0YXRlID0gKHByb3BzOiBJbnB1dFByb3BzKTogUmVhY3QuTm9kZSA9PiB7XG4gICAgbGV0IG5vZGU6IE5vZGUgPSBudWxsO1xuXG4gICAgY29uc3QgeyBjaGlsZHJlbiwgcmVuZGVyLCBpZCwgY29sb3IgfSA9IHByb3BzO1xuXG4gICAgLy8geXVjaywgbmVlZGVkIGZvciB0eXBlIHJlZmluZW1lbnQgOihcbiAgICBpZiAocHJvcHMuc3ZnKSB7XG4gICAgICAgIG5vZGUgPSB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdzdmcnLFxuICAgICAgICAgICAgbm9kZTogcHJvcHMuc3ZnLFxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAocHJvcHMuaWNvbikge1xuICAgICAgICBub2RlID0ge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnaWNvbicsXG4gICAgICAgICAgICBub2RlOiBwcm9wcy5pY29uLFxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAocHJvcHMuaW1hZ2UpIHtcbiAgICAgICAgbm9kZSA9IHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2ltYWdlJyxcbiAgICAgICAgICAgIG5vZGU6IHByb3BzLmltYWdlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuKG5vZGUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiByZW5kZXIobm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdlxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKCdzdGF0ZScsIGNvbG9yID8gUFJFRklYICsgY29sb3IgOiBudWxsKX1cbiAgICAgICAgICAgIGRhdGEtdGVzdGlkPVwicGNyLXN0YXRlXCJcbiAgICAgICAgPlxuICAgICAgICAgICAge25vZGUgPyBmaWxsQ2xhc3NOYW1lRm9ySWNvbnMobm9kZS5ub2RlLCBub2RlLmNsYXNzTmFtZSkgOiBudWxsfVxuICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9e2lkfT57Y2hpbGRyZW59PC9sYWJlbD5cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn07XG5cbmNvbnN0IElucHV0ID0gUmVhY3QuZm9yd2FyZFJlZjxJbnB1dFByb3BzLCBIVE1MSW5wdXRFbGVtZW50PigocHJvcHMsIHJlZikgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgb25DaGFuZ2UsXG4gICAgICAgIGlkLFxuICAgICAgICB0eXBlLFxuICAgICAgICBpbnB1dFByb3BzLFxuICAgICAgICBhbmltYXRpb24sXG4gICAgICAgIGNoZWNrZWQsXG4gICAgICAgIGRpc2FibGVkLFxuICAgICAgICBsb2NrZWQsXG4gICAgICAgIGJpZ2dlcixcbiAgICAgICAgc2hhcGUsXG4gICAgICAgIHN0eWxlLFxuICAgICAgICBwbGFpbixcbiAgICAgICAgcHJldHR5U2VsZWN0b3IgPSAncHJldHR5JyxcbiAgICB9ID0gcHJvcHM7XG5cbiAgICBpZiAoXG4gICAgICAgIChwcm9wcy5pY29uICYmIHByb3BzLnN2ZykgfHxcbiAgICAgICAgKHByb3BzLmljb24gJiYgcHJvcHMuaW1hZ2UpIHx8XG4gICAgICAgIChwcm9wcy5zdmcgJiYgcHJvcHMuaW1hZ2UpXG4gICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdpY29uLCBzdmcsIGFuZCBpbWFnZSBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlIHByb3BzOyBjaG9vc2Ugb25lJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXZcbiAgICAgICAgICAgIGRhdGEtdGVzdGlkPVwicGNyLXdyYXBwZXJcIlxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFxuICAgICAgICAgICAgICAgIHByZXR0eVNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbiA/IFBSRUZJWCArIGFuaW1hdGlvbiA6IG51bGwsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIHNoYXBlID8gUFJFRklYICsgc2hhcGUgOiBudWxsLFxuICAgICAgICAgICAgICAgIHN0eWxlID8gUFJFRklYICsgc3R5bGUgOiBudWxsLFxuICAgICAgICAgICAgICAgIGxvY2tlZCA/IGAke1BSRUZJWH1sb2NrZWRgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBiaWdnZXIgPyBgJHtQUkVGSVh9YmlnZ2VyYCA6IG51bGwsXG4gICAgICAgICAgICAgICAgcGxhaW4gPyBgJHtQUkVGSVh9cGxhaW5gIDogbnVsbFxuICAgICAgICAgICAgKX1cbiAgICAgICAgPlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgaWQ9e2lkIHx8IG51bGx9XG4gICAgICAgICAgICAgICAgdHlwZT17dHlwZX1cbiAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlfVxuICAgICAgICAgICAgICAgIGNoZWNrZWQ9e2NoZWNrZWR9XG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgICAgICAgICAgIGRhdGEtdGVzdGlkPVwicGNyLWlucHV0XCJcbiAgICAgICAgICAgICAgICByZWY9e3JlZn1cbiAgICAgICAgICAgICAgICB7Li4uaW5wdXRQcm9wc31cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gJEV4cGVjdEVycm9yXG4gICAgICAgICAgICAgICAgPFByZXR0eUlucHV0U3RhdGUgey4uLnByb3BzfSAvPlxuICAgICAgICAgICAgfVxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufSk7XG5cbklucHV0LmRpc3BsYXlOYW1lID0gJ0lucHV0JztcblxuZXhwb3J0IGRlZmF1bHQgSW5wdXQ7XG4iLCIvLyBAZmxvd1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbnR5cGUgR2V0QmFzZUNsYXNzTmFtZVByb3BzID0ge1xuICAgIGljb24/OiBSZWFjdC5FbGVtZW50PGFueT4sXG4gICAgc3ZnPzogUmVhY3QuRWxlbWVudDwnc3ZnJz4sXG4gICAgaW1hZ2U/OiBSZWFjdC5FbGVtZW50PCdpbWcnPlxufVxuXG5leHBvcnQgY29uc3QgZ2V0QmFzZUNsYXNzTmFtZSA9ICh7IGljb24sIGltYWdlLCBzdmcgfTogR2V0QmFzZUNsYXNzTmFtZVByb3BzLCBQUkVGSVg6IHN0cmluZykgPT4ge1xuICAgIGxldCBiYXNlID0gYCR7UFJFRklYfWRlZmF1bHRgO1xuXG4gICAgaWYgKGljb24pIHtcbiAgICAgICAgYmFzZSA9IGAke1BSRUZJWH1pY29uYDtcbiAgICB9IGVsc2UgaWYgKHN2Zykge1xuICAgICAgICBiYXNlID0gYCR7UFJFRklYfXN2Z2A7XG4gICAgfSBlbHNlIGlmIChpbWFnZSkge1xuICAgICAgICBiYXNlID0gYCR7UFJFRklYfWltYWdlYDtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZTtcbn07XG4iLCIvLyBAZmxvd1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBnZXRCYXNlQ2xhc3NOYW1lIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xuXG5pbXBvcnQgSW5wdXQsIHsgUFJFRklYIH0gZnJvbSAnLi9JbnB1dCc7XG5pbXBvcnQgdHlwZSB7IElucHV0UHJvcHMgfSBmcm9tICcuL0lucHV0JztcblxuZXhwb3J0IHR5cGUgQ2hlY2tib3hQcm9wcyA9IHtcbiAgICAuLi5JbnB1dFByb3BzLFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRydWUgd2hlbiB0aGUgY2hlY2tib3ggaXMgaW4gYW4gaW5kZXRlcm1pbmF0ZSBzdGF0ZS5cbiAgICAgKi9cbiAgICBpbmRldGVybWluYXRlPzogYm9vbGVhbixcbn07XG5cbmNvbnN0IENoZWNrYm94ID0gUmVhY3QuZm9yd2FyZFJlZjxDaGVja2JveFByb3BzLCBIVE1MSW5wdXRFbGVtZW50PihcbiAgICAocHJvcHMsIHJlZikgPT4ge1xuICAgICAgICBjb25zdCB7IGFuaW1hdGlvbiwgY2xhc3NOYW1lLCAuLi5yZXN0IH0gPSBwcm9wcztcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBhbmltYXRpb24gJiZcbiAgICAgICAgICAgIGFuaW1hdGlvbiAhPT0gJ3Ntb290aCcgJiZcbiAgICAgICAgICAgIGFuaW1hdGlvbiAhPT0gJ3B1bHNlJyAmJlxuICAgICAgICAgICAgIXByb3BzLmljb24gJiZcbiAgICAgICAgICAgICFwcm9wcy5pbWFnZSAmJlxuICAgICAgICAgICAgIXByb3BzLnN2Z1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgYW5pbWF0aW9uICcke2FuaW1hdGlvbn0nIGlzIGluY29tcGF0aWJsZSB3aXRoIGRlZmF1bHQgY2hlY2tib3ggc3R5bGVzLiBZb3UgbXVzdCBzcGVjaWZ5IGFuIGljb24sIGltYWdlLCBvciBhIHN2Zy5gXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxJbnB1dFxuICAgICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFxuICAgICAgICAgICAgICAgICAgICAvLyAkRXhwZWN0RXJyb3JcbiAgICAgICAgICAgICAgICAgICAgZ2V0QmFzZUNsYXNzTmFtZShwcm9wcywgUFJFRklYKSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuaW5kZXRlcm1pbmF0ZSA/ICdwLWhhcy1pbmRldGVybWluYXRlJyA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZVxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uPXthbmltYXRpb259XG4gICAgICAgICAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgICAgICAgICAgey4uLnJlc3R9XG4gICAgICAgICAgICAvPlxuICAgICAgICApO1xuICAgIH1cbik7XG5cbkNoZWNrYm94LmRpc3BsYXlOYW1lID0gJ0NoZWNrYm94JztcblxuZXhwb3J0IGRlZmF1bHQgQ2hlY2tib3g7XG4iLCIvLyBAZmxvd1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBnZXRCYXNlQ2xhc3NOYW1lIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xuXG5pbXBvcnQgSW5wdXQsIHsgUFJFRklYIH0gZnJvbSAnLi9JbnB1dCc7XG5pbXBvcnQgdHlwZSB7IElucHV0UHJvcHMgfSBmcm9tICcuL0lucHV0JztcblxuZXhwb3J0IHR5cGUgUmFkaW9Qcm9wcyA9IHtcbiAgICAuLi5JbnB1dFByb3BzLFxuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHJhZGlvIGdyb3VwLlxuICAgICAqL1xuICAgIG5hbWU6IHN0cmluZyxcbn07XG5cbmNvbnN0IFJhZGlvID0gUmVhY3QuZm9yd2FyZFJlZjxSYWRpb1Byb3BzLCBIVE1MSW5wdXRFbGVtZW50PigocHJvcHMsIHJlZikgPT4ge1xuICAgIGNvbnN0IHsgY2xhc3NOYW1lLCBuYW1lLCBpbnB1dFByb3BzLCBzaGFwZSA9ICdyb3VuZCcsIC4uLnJlc3QgfSA9IHByb3BzO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPElucHV0XG4gICAgICAgICAgICB0eXBlPVwicmFkaW9cIlxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFxuICAgICAgICAgICAgICAgIC8vICRFeHBlY3RFcnJvclxuICAgICAgICAgICAgICAgIGdldEJhc2VDbGFzc05hbWUocHJvcHMsIFBSRUZJWCksXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lXG4gICAgICAgICAgICApfVxuICAgICAgICAgICAgaW5wdXRQcm9wcz17eyAuLi5pbnB1dFByb3BzLCBuYW1lOiBuYW1lIH19XG4gICAgICAgICAgICBzaGFwZT17c2hhcGV9XG4gICAgICAgICAgICByZWY9e3JlZn1cbiAgICAgICAgICAgIHsuLi5yZXN0fVxuICAgICAgICAvPlxuICAgICk7XG59KTtcblxuUmFkaW8uZGlzcGxheU5hbWUgPSAnUmFkaW8nO1xuXG5leHBvcnQgZGVmYXVsdCBSYWRpbztcbiIsIi8vIEBmbG93XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcblxuaW1wb3J0IElucHV0LCB7IFBSRUZJWCB9IGZyb20gJy4vSW5wdXQnO1xuaW1wb3J0IHR5cGUgeyBJbnB1dFByb3BzIH0gZnJvbSAnLi9JbnB1dCc7XG5cbmV4cG9ydCB0eXBlIFN3aXRjaFByb3BzID0ge1xuICAgIC4uLklucHV0UHJvcHMsXG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IGFuaW1hdGlvbiBmb3IgdGhlIGBTd2l0Y2hgIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBhbmltYXRpb24/OiAnc21vb3RoJyB8ICdqZWxseScgfCAndGFkYScsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2hhcGUgb2YgdGhlIGBTd2l0Y2hgIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBzaGFwZT86ICdvdXRsaW5lJyB8ICdmaWxsJyB8ICdzbGltJyxcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGUgYSBuYW1lIHdoZW4gYHR5cGVgIGlzIGByYWRpb2AuXG4gICAgICovXG4gICAgbmFtZT86IHN0cmluZyxcbn07XG5cbmNvbnN0IFN3aXRjaCA9IFJlYWN0LmZvcndhcmRSZWY8U3dpdGNoUHJvcHMsIEhUTUxJbnB1dEVsZW1lbnQ+KChwcm9wcywgcmVmKSA9PiB7XG4gICAgY29uc3QgeyB0eXBlID0gJ2NoZWNrYm94Jywgc2hhcGUgPSAnb3V0bGluZScsIGNsYXNzTmFtZSwgbmFtZSwgaW5wdXRQcm9wcywgLi4ucmVzdCB9ID0gcHJvcHM7XG5cbiAgICBpZiAoXG4gICAgICAgICFzaGFwZSB8fFxuICAgICAgICAoc2hhcGUgIT09ICdvdXRsaW5lJyAmJiBzaGFwZSAhPT0gJ2ZpbGwnICYmIHNoYXBlICE9PSAnc2xpbScpXG4gICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdTaGFwZSBjYW4gYmUgb25lIG9mIHRoZSBmb2xsb3dpbmc6IG91dGxpbmUsIGZpbGwsIG9yIHNsaW0nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHlwZSBpcyByZXF1aXJlZCB0byBiZSBzZXQnKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAgIHJlc3QuYW5pbWF0aW9uICYmXG4gICAgICAgIHJlc3QuYW5pbWF0aW9uICE9PSAnc21vb3RoJyAmJlxuICAgICAgICByZXN0LmFuaW1hdGlvbiAhPT0gJ2plbGx5JyAmJlxuICAgICAgICByZXN0LmFuaW1hdGlvbiAhPT0gJ3RhZGEnXG4gICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdTd2l0Y2ggYW5pbWF0aW9ucyBjYW4gYmUgb25lIG9mIHRoZSBmb2xsb3dpbmc6IHNtb290aCwgamVsbHksIG9yIHRhZGEnXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPElucHV0XG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoYCR7UFJFRklYfXN3aXRjaGAsIGNsYXNzTmFtZSl9XG4gICAgICAgICAgICB0eXBlPXt0eXBlfVxuICAgICAgICAgICAgc2hhcGU9e3NoYXBlfVxuICAgICAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgICAgICBpbnB1dFByb3BzPXt7IC4uLmlucHV0UHJvcHMsIG5hbWU6IG5hbWUgfX1cbiAgICAgICAgICAgIHsuLi5yZXN0fVxuICAgICAgICAvPlxuICAgICk7XG59KTtcblxuU3dpdGNoLmRpc3BsYXlOYW1lID0gJ1N3aXRjaCc7XG5cbmV4cG9ydCBkZWZhdWx0IFN3aXRjaDtcbiJdLCJuYW1lcyI6WyJoYXNPd24iLCJoYXNPd25Qcm9wZXJ0eSIsImNsYXNzTmFtZXMiLCJjbGFzc2VzIiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZyIsImFyZ1R5cGUiLCJwdXNoIiwiQXJyYXkiLCJpc0FycmF5IiwiaW5uZXIiLCJhcHBseSIsImtleSIsImNhbGwiLCJqb2luIiwibW9kdWxlIiwiZXhwb3J0cyIsImRlZmF1bHQiLCJ3aW5kb3ciLCJQUkVGSVgiLCJmaWxsQ2xhc3NOYW1lRm9ySWNvbnMiLCJjb21wb25lbnQiLCJjbGFzc05hbWUiLCJSZWFjdCIsInByb3BzIiwiUHJldHR5SW5wdXRTdGF0ZSIsIm5vZGUiLCJjaGlsZHJlbiIsInJlbmRlciIsImlkIiwiY29sb3IiLCJzdmciLCJpY29uIiwiaW1hZ2UiLCJSZWFjdC5jcmVhdGVFbGVtZW50IiwiSW5wdXQiLCJyZWYiLCJ2YWx1ZSIsIm9uQ2hhbmdlIiwidHlwZSIsImlucHV0UHJvcHMiLCJhbmltYXRpb24iLCJjaGVja2VkIiwiZGlzYWJsZWQiLCJsb2NrZWQiLCJiaWdnZXIiLCJzaGFwZSIsInN0eWxlIiwicGxhaW4iLCJwcmV0dHlTZWxlY3RvciIsIkVycm9yIiwiZGlzcGxheU5hbWUiLCJnZXRCYXNlQ2xhc3NOYW1lIiwiYmFzZSIsIkNoZWNrYm94IiwiZm9yd2FyZFJlZiIsInJlc3QiLCJpbmRldGVybWluYXRlIiwiUmFkaW8iLCJuYW1lIiwiU3dpdGNoIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBT0MsYUFBWTs7TUFHUkEsTUFBTSxHQUFHLEdBQUdDLGNBQWhCOztXQUVTQyxVQUFULEdBQXVCO1FBQ2xCQyxPQUFPLEdBQUcsRUFBZDs7U0FFSyxJQUFJQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHQyxTQUFTLENBQUNDLE1BQTlCLEVBQXNDRixDQUFDLEVBQXZDLEVBQTJDO1VBQ3RDRyxHQUFHLEdBQUdGLFNBQVMsQ0FBQ0QsQ0FBRCxDQUFuQjtVQUNJLENBQUNHLEdBQUwsRUFBVTtVQUVOQyxPQUFPLEdBQUcsT0FBT0QsR0FBckI7O1VBRUlDLE9BQU8sS0FBSyxRQUFaLElBQXdCQSxPQUFPLEtBQUssUUFBeEMsRUFBa0Q7UUFDakRMLE9BQU8sQ0FBQ00sSUFBUixDQUFhRixHQUFiO09BREQsTUFFTyxJQUFJRyxLQUFLLENBQUNDLE9BQU4sQ0FBY0osR0FBZCxLQUFzQkEsR0FBRyxDQUFDRCxNQUE5QixFQUFzQztZQUN4Q00sS0FBSyxHQUFHVixVQUFVLENBQUNXLEtBQVgsQ0FBaUIsSUFBakIsRUFBdUJOLEdBQXZCLENBQVo7O1lBQ0lLLEtBQUosRUFBVztVQUNWVCxPQUFPLENBQUNNLElBQVIsQ0FBYUcs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
