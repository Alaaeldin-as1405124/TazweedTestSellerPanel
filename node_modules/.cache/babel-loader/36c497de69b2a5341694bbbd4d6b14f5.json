{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar React = __importStar(require(\"react\"));\n\nvar ReactDOM = __importStar(require(\"react-dom\"));\n\nvar utils_1 = require(\"./utils\");\n\nvar AUTOSCROLL_ACTIVE_OFFSET = 200;\nvar AUTOSCROLL_SPEED_RATIO = 10;\n\nvar List =\n/** @class */\nfunction (_super) {\n  __extends(List, _super);\n\n  function List(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.listRef = React.createRef();\n    _this.ghostRef = React.createRef();\n    _this.topOffsets = [];\n    _this.itemTranslateOffsets = [];\n    _this.initialYOffset = 0;\n    _this.lastScroll = 0;\n    _this.needle = -1;\n    _this.afterIndex = -2;\n    _this.state = {\n      itemDragged: -1,\n      itemDraggedOutOfBounds: -1,\n      selectedItem: -1,\n      initialX: 0,\n      initialY: 0,\n      targetX: 0,\n      targetY: 0,\n      targetHeight: 0,\n      targetWidth: 0,\n      liveText: '',\n      scrollingSpeed: 0,\n      scrollWindow: false\n    };\n\n    _this.doScrolling = function () {\n      var _a = _this.state,\n          scrollingSpeed = _a.scrollingSpeed,\n          scrollWindow = _a.scrollWindow;\n      var listEl = _this.listRef.current;\n      window.requestAnimationFrame(function () {\n        if (scrollWindow) {\n          window.scrollTo(window.pageXOffset, window.pageYOffset + scrollingSpeed * 1.5);\n        } else {\n          listEl.scrollTop += scrollingSpeed;\n        }\n\n        if (scrollingSpeed !== 0) {\n          _this.doScrolling();\n        }\n      });\n    };\n\n    _this.getChildren = function () {\n      if (_this.listRef && _this.listRef.current) {\n        return Array.from(_this.listRef.current.children);\n      }\n\n      console.warn('No items found in the List container. Did you forget to pass & spread the `props` param in renderList?');\n      return [];\n    };\n\n    _this.calculateOffsets = function () {\n      _this.topOffsets = _this.getChildren().map(function (item) {\n        return item.getBoundingClientRect().top;\n      });\n      _this.itemTranslateOffsets = _this.getChildren().map(function (item) {\n        return utils_1.getTranslateOffset(item);\n      });\n    };\n\n    _this.getTargetIndex = function (e) {\n      return _this.getChildren().findIndex(function (child) {\n        return child === e.target || child.contains(e.target);\n      });\n    };\n\n    _this.onMouseOrTouchStart = function (e) {\n      var isTouch = utils_1.isTouchEvent(e);\n      if (!isTouch && e.button !== 0) return;\n\n      var index = _this.getTargetIndex(e);\n\n      if (index === -1 || // @ts-ignore\n      _this.props.values[index] && _this.props.values[index].disabled) return;\n\n      var listItemTouched = _this.getChildren()[index];\n\n      var handle = listItemTouched.querySelector('[data-movable-handle]');\n\n      if (handle && !handle.contains(e.target)) {\n        return;\n      }\n\n      if (utils_1.checkIfInteractive(e.target, listItemTouched)) {\n        return;\n      }\n\n      e.preventDefault();\n      _this.props.beforeDrag && _this.props.beforeDrag({\n        elements: _this.getChildren(),\n        index: index\n      });\n\n      if (isTouch) {\n        var opts = {\n          passive: false\n        };\n        document.addEventListener('touchend', _this.schdOnEnd, opts);\n        document.addEventListener('touchmove', _this.schdOnTouchMove, opts);\n        document.addEventListener('touchcancel', _this.schdOnEnd, opts);\n      } else {\n        document.addEventListener('mousemove', _this.schdOnMouseMove);\n        document.addEventListener('mouseup', _this.schdOnEnd);\n      }\n\n      _this.onStart(listItemTouched, isTouch ? e.touches[0].clientX : e.clientX, isTouch ? e.touches[0].clientY : e.clientY, index);\n    };\n\n    _this.getYOffset = function () {\n      var listScroll = _this.listRef.current ? _this.listRef.current.scrollTop : 0;\n      return window.pageYOffset + listScroll;\n    };\n\n    _this.onStart = function (target, clientX, clientY, index) {\n      if (_this.state.selectedItem > -1) {\n        _this.setState({\n          selectedItem: -1\n        });\n\n        _this.needle = -1;\n      }\n\n      var targetRect = target.getBoundingClientRect();\n      var targetStyles = window.getComputedStyle(target);\n\n      _this.calculateOffsets();\n\n      _this.initialYOffset = _this.getYOffset();\n\n      _this.setState({\n        itemDragged: index,\n        targetX: targetRect.left - parseInt(targetStyles['margin-left'], 10),\n        targetY: targetRect.top - parseInt(targetStyles['margin-top'], 10),\n        targetHeight: targetRect.height,\n        targetWidth: targetRect.width,\n        initialX: clientX,\n        initialY: clientY\n      });\n    };\n\n    _this.onMouseMove = function (e) {\n      e.cancelable && e.preventDefault();\n\n      _this.onMove(e.clientX, e.clientY);\n    };\n\n    _this.onTouchMove = function (e) {\n      e.cancelable && e.preventDefault();\n\n      _this.onMove(e.touches[0].clientX, e.touches[0].clientY);\n    };\n\n    _this.onWheel = function (e) {\n      if (_this.state.itemDragged < 0) return;\n      _this.lastScroll = _this.listRef.current.scrollTop += e.deltaY;\n\n      _this.moveOtherItems();\n    };\n\n    _this.onMove = function (clientX, clientY) {\n      if (_this.state.itemDragged === -1) return null;\n      utils_1.transformItem(_this.ghostRef.current, clientY - _this.state.initialY, _this.props.lockVertically ? 0 : clientX - _this.state.initialX);\n\n      _this.autoScrolling(clientY);\n\n      _this.moveOtherItems();\n    };\n\n    _this.moveOtherItems = function () {\n      var targetRect = _this.ghostRef.current.getBoundingClientRect();\n\n      var itemVerticalCenter = targetRect.top + targetRect.height / 2;\n      var offset = utils_1.getTranslateOffset(_this.getChildren()[_this.state.itemDragged]);\n\n      var currentYOffset = _this.getYOffset(); // adjust offsets if scrolling happens during the item movement\n\n\n      if (_this.initialYOffset !== currentYOffset) {\n        _this.topOffsets = _this.topOffsets.map(function (offset) {\n          return offset - (currentYOffset - _this.initialYOffset);\n        });\n        _this.initialYOffset = currentYOffset;\n      }\n\n      if (_this.isDraggedItemOutOfBounds() && _this.props.removableByMove) {\n        _this.afterIndex = _this.topOffsets.length + 1;\n      } else {\n        _this.afterIndex = utils_1.binarySearch(_this.topOffsets, itemVerticalCenter);\n      }\n\n      _this.animateItems(_this.afterIndex === -1 ? 0 : _this.afterIndex, _this.state.itemDragged, offset);\n    };\n\n    _this.autoScrolling = function (clientY) {\n      var _a = _this.listRef.current.getBoundingClientRect(),\n          top = _a.top,\n          bottom = _a.bottom,\n          height = _a.height;\n\n      var viewportHeight = window.innerHeight || document.documentElement.clientHeight; // autoscrolling for the window (down)\n\n      if (bottom > viewportHeight && viewportHeight - clientY < AUTOSCROLL_ACTIVE_OFFSET) {\n        _this.setState({\n          scrollingSpeed: Math.round((AUTOSCROLL_ACTIVE_OFFSET - (viewportHeight - clientY)) / AUTOSCROLL_SPEED_RATIO),\n          scrollWindow: true\n        }); // autoscrolling for the window (up)\n\n      } else if (top < 0 && clientY < AUTOSCROLL_ACTIVE_OFFSET) {\n        _this.setState({\n          scrollingSpeed: Math.round((AUTOSCROLL_ACTIVE_OFFSET - clientY) / -AUTOSCROLL_SPEED_RATIO),\n          scrollWindow: true\n        });\n      } else {\n        if (_this.state.scrollWindow && _this.state.scrollingSpeed !== 0) {\n          _this.setState({\n            scrollingSpeed: 0,\n            scrollWindow: false\n          });\n        } // autoscrolling for containers with overflow\n\n\n        if (height + 20 < _this.listRef.current.scrollHeight) {\n          var scrollingSpeed = 0;\n\n          if (clientY - top < AUTOSCROLL_ACTIVE_OFFSET) {\n            scrollingSpeed = Math.round((AUTOSCROLL_ACTIVE_OFFSET - (clientY - top)) / -AUTOSCROLL_SPEED_RATIO);\n          } else if (bottom - clientY < AUTOSCROLL_ACTIVE_OFFSET) {\n            scrollingSpeed = Math.round((AUTOSCROLL_ACTIVE_OFFSET - (bottom - clientY)) / AUTOSCROLL_SPEED_RATIO);\n          }\n\n          if (_this.state.scrollingSpeed !== scrollingSpeed) {\n            _this.setState({\n              scrollingSpeed: scrollingSpeed\n            });\n          }\n        }\n      }\n    };\n\n    _this.animateItems = function (needle, movedItem, offset, animateMovedItem) {\n      if (animateMovedItem === void 0) {\n        animateMovedItem = false;\n      }\n\n      _this.getChildren().forEach(function (item, i) {\n        utils_1.setItemTransition(item, _this.props.transitionDuration);\n\n        if (movedItem === i && animateMovedItem) {\n          if (movedItem === needle) {\n            return utils_1.transformItem(item, null);\n          }\n\n          utils_1.transformItem(item, movedItem < needle ? _this.itemTranslateOffsets.slice(movedItem + 1, needle + 1).reduce(function (a, b) {\n            return a + b;\n          }, 0) : _this.itemTranslateOffsets.slice(needle, movedItem).reduce(function (a, b) {\n            return a + b;\n          }, 0) * -1);\n        } else if (movedItem < needle && i > movedItem && i <= needle) {\n          utils_1.transformItem(item, -offset);\n        } else if (i < movedItem && movedItem > needle && i >= needle) {\n          utils_1.transformItem(item, offset);\n        } else {\n          utils_1.transformItem(item, null);\n        }\n      });\n    };\n\n    _this.isDraggedItemOutOfBounds = function () {\n      var initialRect = _this.getChildren()[_this.state.itemDragged].getBoundingClientRect();\n\n      var targetRect = _this.ghostRef.current.getBoundingClientRect();\n\n      if (Math.abs(initialRect.left - targetRect.left) > targetRect.width) {\n        if (_this.state.itemDraggedOutOfBounds === -1) {\n          _this.setState({\n            itemDraggedOutOfBounds: _this.state.itemDragged\n          });\n        }\n\n        return true;\n      }\n\n      if (_this.state.itemDraggedOutOfBounds > -1) {\n        _this.setState({\n          itemDraggedOutOfBounds: -1\n        });\n      }\n\n      return false;\n    };\n\n    _this.onEnd = function (e) {\n      e.cancelable && e.preventDefault();\n      document.removeEventListener('mousemove', _this.schdOnMouseMove);\n      document.removeEventListener('touchmove', _this.schdOnTouchMove);\n      document.removeEventListener('mouseup', _this.schdOnEnd);\n      document.removeEventListener('touchup', _this.schdOnEnd);\n      document.removeEventListener('touchcancel', _this.schdOnEnd);\n\n      var isOutOfBounds = _this.isDraggedItemOutOfBounds();\n\n      if (_this.props.removableByMove && isOutOfBounds || _this.afterIndex > -1 && _this.state.itemDragged !== _this.afterIndex) {\n        _this.props.onChange({\n          oldIndex: _this.state.itemDragged,\n          newIndex: _this.props.removableByMove && isOutOfBounds ? -1 : _this.afterIndex,\n          targetRect: _this.ghostRef.current.getBoundingClientRect()\n        });\n      }\n\n      _this.getChildren().forEach(function (item) {\n        utils_1.setItemTransition(item, 0);\n        utils_1.transformItem(item, null);\n      });\n\n      _this.setState({\n        itemDragged: -1,\n        scrollingSpeed: 0\n      });\n\n      _this.afterIndex = -2; // sometimes the scroll gets messed up after the drop, fix:\n\n      if (_this.lastScroll > 0) {\n        _this.listRef.current.scrollTop = _this.lastScroll;\n        _this.lastScroll = 0;\n      }\n    };\n\n    _this.onKeyDown = function (e) {\n      var selectedItem = _this.state.selectedItem;\n\n      var index = _this.getTargetIndex(e);\n\n      if (index === -1) return;\n\n      if (e.key === ' ') {\n        e.preventDefault();\n\n        if (selectedItem === index) {\n          if (selectedItem !== _this.needle) {\n            _this.getChildren().forEach(function (item) {\n              utils_1.setItemTransition(item, 0);\n              utils_1.transformItem(item, null);\n            });\n\n            _this.props.onChange({\n              oldIndex: selectedItem,\n              newIndex: _this.needle,\n              targetRect: _this.getChildren()[_this.needle].getBoundingClientRect()\n            });\n\n            _this.getChildren()[_this.needle].focus();\n          }\n\n          _this.setState({\n            selectedItem: -1,\n            liveText: _this.props.voiceover.dropped(selectedItem + 1, _this.needle + 1)\n          });\n\n          _this.needle = -1;\n        } else {\n          _this.setState({\n            selectedItem: index,\n            liveText: _this.props.voiceover.lifted(index + 1)\n          });\n\n          _this.needle = index;\n\n          _this.calculateOffsets();\n        }\n      }\n\n      if ((e.key === 'ArrowDown' || e.key === 'j') && selectedItem > -1 && _this.needle < _this.props.values.length - 1) {\n        e.preventDefault();\n        var offset = utils_1.getTranslateOffset(_this.getChildren()[selectedItem]);\n        _this.needle++;\n\n        _this.animateItems(_this.needle, selectedItem, offset, true);\n\n        _this.setState({\n          liveText: _this.props.voiceover.moved(_this.needle + 1, false)\n        });\n      }\n\n      if ((e.key === 'ArrowUp' || e.key === 'k') && selectedItem > -1 && _this.needle > 0) {\n        e.preventDefault();\n        var offset = utils_1.getTranslateOffset(_this.getChildren()[selectedItem]);\n        _this.needle--;\n\n        _this.animateItems(_this.needle, selectedItem, offset, true);\n\n        _this.setState({\n          liveText: _this.props.voiceover.moved(_this.needle + 1, true)\n        });\n      }\n\n      if (e.key === 'Escape' && selectedItem > -1) {\n        _this.getChildren().forEach(function (item) {\n          utils_1.setItemTransition(item, 0);\n          utils_1.transformItem(item, null);\n        });\n\n        _this.setState({\n          selectedItem: -1,\n          liveText: _this.props.voiceover.canceled(selectedItem + 1)\n        });\n\n        _this.needle = -1;\n      }\n\n      if ((e.key === 'Tab' || e.key === 'Enter') && selectedItem > -1) {\n        e.preventDefault();\n      }\n    };\n\n    _this.schdOnMouseMove = utils_1.schd(_this.onMouseMove);\n    _this.schdOnTouchMove = utils_1.schd(_this.onTouchMove);\n    _this.schdOnEnd = utils_1.schd(_this.onEnd);\n    return _this;\n  }\n\n  List.prototype.componentDidMount = function () {\n    this.calculateOffsets();\n    document.addEventListener('touchstart', this.onMouseOrTouchStart, {\n      passive: false,\n      capture: false\n    });\n    document.addEventListener('mousedown', this.onMouseOrTouchStart);\n  };\n\n  List.prototype.componentDidUpdate = function (_prevProps, prevState) {\n    if (prevState.scrollingSpeed !== this.state.scrollingSpeed && prevState.scrollingSpeed === 0) {\n      this.doScrolling();\n    }\n  };\n\n  List.prototype.componentWillUnmount = function () {\n    document.removeEventListener('touchstart', this.onMouseOrTouchStart);\n    document.removeEventListener('mousedown', this.onMouseOrTouchStart);\n  };\n\n  List.prototype.render = function () {\n    var _this = this;\n\n    var baseStyle = {\n      userSelect: 'none',\n      touchAction: 'none',\n      WebkitUserSelect: 'none',\n      MozUserSelect: 'none',\n      msUserSelect: 'none',\n      boxSizing: 'border-box',\n      position: 'relative'\n    };\n\n    var ghostStyle = __assign({}, baseStyle, {\n      top: this.state.targetY,\n      left: this.state.targetX,\n      width: this.state.targetWidth,\n      height: this.state.targetHeight,\n      display: 'block',\n      position: 'fixed',\n      marginTop: 0\n    });\n\n    return React.createElement(React.Fragment, null, this.props.renderList({\n      children: this.props.values.map(function (value, index) {\n        var isHidden = index === _this.state.itemDragged;\n        var isSelected = index === _this.state.selectedItem;\n        var isDisabled = // @ts-ignore\n        _this.props.values[index] && _this.props.values[index].disabled;\n        var props = {\n          key: index,\n          tabIndex: isDisabled ? -1 : 0,\n          'aria-roledescription': _this.props.voiceover.item(index + 1),\n          onKeyDown: _this.onKeyDown,\n          style: __assign({}, baseStyle, {\n            visibility: isHidden ? 'hidden' : undefined,\n            zIndex: isSelected ? 5000 : 0\n          })\n        };\n        return _this.props.renderItem({\n          value: value,\n          props: props,\n          index: index,\n          isDragged: false,\n          isSelected: isSelected,\n          isOutOfBounds: false\n        });\n      }),\n      isDragged: this.state.itemDragged > -1,\n      props: {\n        ref: this.listRef\n      }\n    }), this.state.itemDragged > -1 && ReactDOM.createPortal(this.props.renderItem({\n      value: this.props.values[this.state.itemDragged],\n      props: {\n        ref: this.ghostRef,\n        style: ghostStyle,\n        onWheel: this.onWheel\n      },\n      index: this.state.itemDragged,\n      isDragged: true,\n      isSelected: false,\n      isOutOfBounds: this.state.itemDraggedOutOfBounds > -1\n    }), document.body), React.createElement(\"div\", {\n      \"aria-live\": \"assertive\",\n      role: \"log\",\n      \"aria-atomic\": \"true\",\n      style: {\n        position: 'absolute',\n        width: '1px',\n        height: '1px',\n        margin: '-1px',\n        border: '0px',\n        padding: '0px',\n        overflow: 'hidden',\n        clip: 'react(0px, 0px, 0px, 0px)',\n        clipPath: 'inset(100%)'\n      }\n    }, this.state.liveText));\n  };\n\n  List.defaultProps = {\n    transitionDuration: 300,\n    lockVertically: false,\n    removableByMove: false,\n    voiceover: {\n      item: function (position) {\n        return \"You are currently at a draggable item at position \" + position + \". Press space bar to lift.\";\n      },\n      lifted: function (position) {\n        return \"You have lifted item at position \" + position + \". Press j to move down, k to move up, space bar to drop and escape to cancel.\";\n      },\n      moved: function (position, up) {\n        return \"You have moved the lifted item \" + (up ? 'up' : 'down') + \" to position \" + position + \". Press j to move down, k to move up, space bar to drop and escape to cancel.\";\n      },\n      dropped: function (from, to) {\n        return \"You have dropped the item. It has moved from position \" + from + \" to \" + to + \".\";\n      },\n      canceled: function (position) {\n        return \"You have cancelled the movement. The item has returned to its starting position of \" + position + \".\";\n      }\n    }\n  };\n  return List;\n}(React.Component);\n\nexports.default = List;","map":null,"metadata":{},"sourceType":"script"}